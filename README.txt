Project1 README file

Η εργασία υλοποιήθηκε από: Ευάγγελος Νεαμονίτης ΑΜ:1115201400123
sdi1400123@di.uoa.gr


Έχουν υλοποιηθεί όλα τα ερωτήματα και η εργασία τρέχει στα μηχανήματα της σχολής (δοκιμασμένη στο linux29 και linuxvm01).

Έχει τεσταριστεί με valgrind οτι δεν υπάρχουν memory leaks με είσοδο όλα τα αρχεία που δόθηκαν.

Έχει γίνει Makefile οπότε για compilation χρειάζεται απλά ενα make.


Το πρόγραμμα λειτουργεί με τα flags -b (hashentries) -l (inputfile).
Απαραίτητο είναι μόνο το -b (hashentries).
Η σειρά με την οποία δίνονται τα flags δεν έχει σημασία.
Αν δεν δοθεί αρχείο είσοδος γίνεται το stdin. 

Η εκτέλεση γίνεται με έναν από τους παρακάτω τρόπους:

./stucs -b (hashmapsize) -l (inputfilename)
./stucs -l (inputfilename) -b (hashmapsize)
./stucs -b (hashmapsize)
./stucs -b hashmapsize <(inputfilename)

Οι δυο βασικές Δομές:

SKIPLIST:
Υλοποιήθηκε με βάση το link που δόθηκε στην εκφώνηση της άσκησης.
Το maxlevel και το maxvalues γίνονται #define στην αρχή του skiplist.c
(από όπου μπορούν και να αλλαχτούν).

HASHMAP:
Υλοποιήθηκε με απλό τρόπο καθώς δεν θεωρήθηκε σημαντικό να γίνει κάτι άλλο.
Η συνάρτηση που δίνει την Θέση ειναι η: postcode%hashmapsize.
Κάθε Θέση του πίνακα έχει μια συνδεδεμένη λίστα με δείκτες σε μαθητές.

Δεν έχει γίνει preallocation για τις βασικές δομές(hashmap skiplist linked list)
Preallocation έχει γίνει μόνο για μικρούς πίνακες που δεν το μεγεθός τους είναι σταθερό

Οι 13 Συναρτήσεις που ζητήθηκαν:

insert:
	Μια εισαγωγή στην skiplist έχει στη χειρότερη περίπτωση Ο(n).
	Αν η εισαγωγή σε αυτή πετύχει, τότε γίνεται εισαγωγή και στον hashmap
	με κόστος Ο(1) αφού οι θέσεις του hashmap έχουν μονή λίστα στην οποία
	γίνεται εισαγωγή στην αρχή.

query:
	αναζήτηση στην skiplist. Στη χειρότερη περίπτωση Ο(n).

modify:
	αναζήτηση στην skiplist. Στη χειρότερη περίπτωση Ο(n).

delete:
	αναζήτηση στην skiplist σε Ο(n) και αν βρεθεί ο φοιτητής
	αναζήτηση με βάση τον postcode μέσα στον hashmap σε O(k) οπου k
	οι φοιτητές που κάνουν hash στην ίδια θέση.
	Συνολικά Ο(n+k) όπου στη χειρότερη (n=k) έχουμε O(2n)=O(n).

raverage:
	Μια προσπέλαση όλης της skiplist στη χειρότερη 
	(studida ο πρώτος και studidb ο τελευταίος) δηλαδή O(n).

average:
	Αναζήτηση της θέσης στην οποία κάνει hash ο συγκεκριμένος postcode O(1) 
	και προσπέλαση της λιστας στη θέση αυτη σε O(k) οπου k όλοι όσοι έκαναν hash
	στην ίδια θεση (οι οποίοι μπορεί να είναι πιο πολλοί από αυτούς 
	που ζουν στο postcode μιας και παραπάνω postcodes μπορεί να κάνουν 
	hash στην ίδια θεση).

taverage:
	Αναζήτηση της θέσης στην οποία κάνει hash ο συγκεκριμένος postcode O(1).
	Δημηουργείται ενας πίνακας k θέσεων. Οσο γίνεται προσπέλαση της λίστας
	διατηρείται ο πινακας με τους k καλύτερους και κάθε φορά που ένας 
	καινούριος μπαίνει γίνεται εύρεση του νεου ελαχίστου στον πίνακα σε Ο(k).
	Επομένως η συνολική πολυπλοκότητα είναι O(n*k) οπου όμως το k<<n.
	εδώ όμως το n είναι οι φοιτητές με postcode που κάνουν hash στην 
	ίδια θέση όχι όλο το ΕΚΠΑ.

bottom:
	Διατρέχοντας όλη τη skiplist διατηρούνται σε έναν πίνακα k θέσεων
	οι χειρότεροι φοιτητές. (διατηρηση του πίνακα σε O(k)).
	Συνολικά  O(n*k) οπου n όλοι οι φοιτητές του ΕΚΠΑ.

courses to take:
	Αναζήτηση της θέσης στην οποία κάνει hash ο συγκεκριμένοςpostcode σε O(1).
	προσπέλαση της λιστας σε O(k) όπου k οι φοιτητές με postcode που κάνοτν
	hash στην ίδια θέση.

find:
	Αρχικά αναζητάται ο μέγιστος αριθμός από μαθήματα σε O(n).
	Μετά γίνεται μια προσπέλαση όλης της skiplist για να βρεθούν
	όσοι χρωστάνε τον ίδιο αριθμό (και εχουν gpa > του gpa που δόθηκε)
	O(n).Συνολικά O(n+n)=O(n).

percentille:
	Αναζήτηση της θέσης στην οποία κάνει hash ο συγκεκριμένος postcode O(1).
	Προσπέλαση της λίστας σε O(K) οπου k όλοι οι φοιτητές στην ίδια λίστα.
	Σύνολο Ο(k).

Percentilles:
	Διατρέχεται όλη η skip list O(n) και διατηρείται ενας δυσδιάστατος πίνακας
	που στην αριστερή στήλη έχει τα postcodes και στην δεξιά πόσους απο το
	κάθε postcode βρήκε στην skiplist.Αν k οι postcodes του πίνακα τότε η
	τελική πολυπλοκότητα είναι O(n*k). Όσο  για το μέγεθος του πίνακα 
	αυτό είναι δυναμικό. Ξεκινάει από 30 θέσεις που είναι ένας 
	επαρκής αριθμός. Αν ο πίνακας αυτός γεμίσει τότε διπλασιάζεται,
	πράγμα που τηα γίνει ελάχιστες φορές με βαση τη λογική.

exit:
	Απελευθερώνεται όλη η μνήμη την οποία καταλαμβάνουν οι δομές κατά τη διάρκεια
	του προγράματος και τερματίζεται η εκτέλεση.




Links από πηγές:

http://stackoverflow.com/questions/3889992/how-does-strtok-split-the-string-into-tokens-in-c

***for (char *p = strtok(s," "); p != NULL; p = strtok(NULL, " "))***

https://piazza.com/class/itr4dcsa8he3vw?cid=33

******while ((getline(&line, &len, fp)) != EOF)*****


bubblesort from http://www.programmingsimplified.com/c/source-code/c-program-bubble-sort

******for (j = 0 ; j < (i-1); j++)
{
	for (z = 0 ; z < i -j-1 ; z++)
	{
		if (starray[z]->gpa > starray[z+1]->gpa) 
		{
			swap = starray[z];
			starray[z] = starray[z+1];
			starray[z+1] = swap;
		}
	}
}*********
	



	 
















